# Visibility Stream

(TODO: earlier generations than A6xx)

The visibility stream is a stream of bits, generated by the binning pass and used during the main pass, that tells, for each primitive in each draw, which bins it covers. It's written in a compressed form by the VSC (visibility stream compressor, probably) to a driver-allocated buffer and then decompressed when needed. It's read by both the CP (to skip entire draws) and the rasterization unit (to skip triangles). This document describes the compressed format.

Note that there are multiple VSC pipes which can be configured to handle different parts of the framebuffer, and each pipe has its own space to write its own visibility stream. Thus each stream only contains info for the bins managed by that pipe.

## Format

There are two kinds of visibility streams: a single per-draw stream and multiple per-primitive streams, one per non-empty draw. The draw stream and primitive streams are put in separate buffers, with separate sizes. The draw stream contains a bitfield of the bins covered by each draw, as well as a pointer to the corresponding primitive stream for each draw.

A stream is conceptually just an array of bits. Structures in the stream are variable-sized, with no alignment, not even byte alignment. To convert the array of bytes in memory to an array of bits, just write each byte in binary, in the usual way with the MSB first, and then concatenate them. Thus, the first bit is the MSB of the first byte, the second bit is bit 6 of the first byte, and so on. When a number needs to be encoded in the stream, we write it in binary in the same way and then append it to the stream. The number is, in a sense, "big-endian" because the most significant bits are always in the first byte when encoded in memory. However, there is no alignment so the number can start on any bit and take up any number of bits.

## Encoding

Both kinds of streams consist of a series of variable-length "packets". Each packet ends with a checksum bit which consists of the previous bits XOR'ed together, so it's 1 if there are an odd number of 1's and 0 if there are an even number.

### Numbers

When a number needs to be encoded in a packet, a variable-length scheme is used. To encode a number, first cut it down to the smallest number of bits possible, so that the first (most significant) bit is always 1. If it's `n` bits, first write `n - 1` zeros, and then the number itself (including the leading 1). Note that it's impossible to encode 0 with this scheme, so the number must be strictly positive. The encoding of the first few numbers are shown below as examples:

- 1: `1`
- 2: `010`
- 3: `011`
- 4: `00100`
- 5: `00101`
- 6: `00110`
- 7: `00111`

### Bitfields

We also need a way to encode a bitfield of bins covered. Since not covering any bin is the most common, a compressed encoding is used where just `0` indicates that no bins are covered, whereas `1` followed by the actual bitfield is used for all non-zero bitfields.

### Primitive streams

The primitive stream uses a run-length encoding, where each packet contains a bitfield of bins covered and then the number of primitives which have the same bitfield. Each packet consists of the following, in order:

- The (compressed) bitfield of bins covered
- The number of primitives with this bitset
- Checksum

For example, let's say the VSC pipe has 4 bins, there's a draw with 10 triangles, and the first five cover all 4 bins while the next 5 cover no bins. Then the visibility stream for this draw would be:

`11111 (bitfield) 00101 (5 triangles) 1 (checksum)  0 (bitfield) 00101 (5 triangles) 0 (checksum)`

Or, the actual bytes in memory:

`f9 62 80 00`

Despite the fact that primitive streams take a non-aligned number of bits, each stream must start on a DWORD-aligned offset. Thus there may be some padding between primitive streams for different draws, as in the example above. This also corresponds to the fact that the sizes reported by the VSC are always a multiple of 4.

### Draw streams

Draw streams only use a run-length encoding for the skipped draws, i.e draws which don't cover anything. Each packet begins again with a compressed bitfield, which is the logical OR of all the bitfields for each primitive in the draw. It's followed by a single bit pertaining to instancing, and then a variable-length number. Packets with a non-zero bitfield always represent a single instance of a single draw, and the number is the size of the primitive stream for that instance in DWORD's. The decoder figures out where each primitive stream is located by accumulating the sizes. Packets with a zero bitfield have no primitive stream, so the number instead represents the number of empty draws to skip.

Instanced draws are *mostly* just treated like each instance is a separate draw. For non-empty draws, the instance bit is 0 if this is the last instance in a draw, and 1 otherwise. Empty draws are similar, however there's a catch: if it's zero, then we assume that *all* remaining instances in the current draw are empty. Hence the number field is redundant, and it's reused as follows: it's subtracted by one, and then the remaining number of draws after the instanced draw are also skipped. Note that in the case where there are only non-instanced draws, this corresponds to the normal behavior you'd expect (the given number of draws, including the current draw, are skipped). However, it leads to something more interesting when skipping part of an instanced draw. Let's say that there's an instanced draw with ten instances, where the last 9 are empty, followed by a non-instanced draw which is entirely empty. First there's a non-empty draw packet, for the first instance, with an instance bit of 1. Then there is an empty draw packet with an instance bit of 0 and a number of 2. This packet skips the 9 remaining instances, decrements the number to 1, and then skips the 1 remaining empty draw. If we only wanted to skip some of those 9 remaining instances, then we could set the instance bit to 1 and the number to the number of instances to skip. Note that the remaining draws to be skipped must be non-instanced. In my testing, the VSC will not emit a skip packet that skips multiple instanced draws.

In summary, each draw stream packet contains the following:
- Bin bitfield
- Last instance bit
- If bitfield is empty, the number of draws it is empty for, otherwise the size of the corresponding primitive stream in DWORD's.
- Checksum

If there are `N` bins, the final packet, after all the draws are done, consists of a 1 followed by `N + 17` 0's, plus a final 1. This uses the otherwise-unused pattern of a non-empty bitfield (initial 1) that is nontheless empty (has all 0's). This is the entirety of the final packet, according to the sizes reported through `VSC_SIZE_ADDRESS`, i.e. the normal 17-bit number and checksum that would normally be there don't exist. Note that the size reported by the VSC is always a multiple of 4, i.e. it's rounded up to a DWORD boundary.